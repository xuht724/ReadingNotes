# ä»¥å¤ªåŠå¦‚ä½•ç”ŸæˆåŒºå—

æˆ‘ä»¬çŸ¥é“å¯¹äºåŒºå—é“¾çš„èŠ‚ç‚¹åœ¨æ‰§è¡Œçš„æ—¶å€™ï¼Œéœ€è¦æ‰§è¡Œä¸€æ‰¹äº¤æ˜“ç”Ÿæˆæ–°çš„çŠ¶æ€ï¼Œå¹¶ä¸”æ ¹æ®è¯¥ä¸–ç•ŒçŠ¶æ€æ‰“åŒ…ç”ŸæˆåŒºå—ã€‚æœ€è¿‘åœ¨å°è¯•åšè¿™éƒ¨åˆ†çš„ä¼˜åŒ–ï¼Œå‘ç°å…³äºåŒºå—ç”Ÿæˆçš„ç»†èŠ‚ï¼Œä¾‹å¦‚åŒºå—å¤´ä¸­çš„å­—æ®µ(`stateRoot,BlockHash,nonce e.g`)å¦‚ä½•ç”Ÿæˆï¼Œç°æœ‰èµ„æ–™æ²¡æœ‰è¯¦ç»†ä»‹ç»ã€‚è¿™ç¯‡æ–‡ç« å°†æ ¹æ®ä»¥å¤ªåŠåŸç æ¢³ç†ä»¥å¤ªåŠåœ¨æŒ‘é€‰å®Œäº¤æ˜“ä¹‹åç›´åˆ°ç”ŸæˆåŒºå—è¿™ä¸€è¯¦ç»†è¿‡ç¨‹ã€‚

## ä»¥å¤ªåŠåŒºå—ç»“æ„

é¦–å…ˆç®€å•ä»‹ç»ä»¥å¤ªåŠåŒºå—ç”±åŒºå—å¤´å’ŒåŒºå—ä½“ç»„æˆã€‚

åŒºå—ä½“ç”¨listçš„æ–¹å¼å­˜å‚¨äº†æœ¬åŒºå—ä¼šè¢«åŒ…å«çš„äº¤æ˜“åˆ—è¡¨ï¼Œä»¥åŠä¼šè¢«ä½¿ç”¨çš„å”å—

````go
// Body is a simple (mutable, non-safe) data container for storing and moving
// a block's data contents (transactions and uncles) together.
type Body struct {
	Transactions []*Transaction
	Uncles       []*Header
}
````

åŒºå—å¤´åŒ…å«äº†åŒºå—çš„æè¿°æ€§ä¿¡æ¯ï¼Œç°æœ‰åŒºå—å¤´åŒ…å«äº†16ä¸ªå­—æ®µï¼Œå…¶ä¸­é™¤äº†BaseFeeä¹‹å¤–éƒ½æ˜¯æœ€å¼€å§‹å­˜åœ¨çš„ï¼ŒBaseFeeæ˜¯Londonç¡¬åˆ†å‰å¼•å…¥çš„æ–°å­—æ®µï¼Œç”¨æ¥è®¡ç®—EIP2718äº¤æ˜“çš„æ‰‹ç»­è´¹ã€‚ä»¥å¤ªåŠåœ¨è®¡ç®—BlockHashçš„æ—¶å€™ï¼Œéœ€è¦åšçš„å°±æ˜¯å°†è¿™16ä¸ªå­—æ®µè¿›è¡ŒRLPç¼–ç ä¹‹åä½¿ç”¨Keccak256å“ˆå¸Œç®—æ³•è®¡ç®—å…¶å“ˆå¸Œå€¼ã€‚ä¹Ÿå°±æ˜¯è¯´åªæœ‰å½“è¿™16ä¸ªå­—æ®µéƒ½ç”Ÿæˆä¹‹åæ‰èƒ½å¾—åˆ°åŒºå—çš„BlockHashã€‚

```go
// Header represents a block header in the Ethereum blockchain.
type Header struct {
	ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
	UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
	Coinbase    common.Address `json:"miner"`
	Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
	TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
	ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
	Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
	Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
	Number      *big.Int       `json:"number"           gencodec:"required"`
	GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
	GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
	Time        uint64         `json:"timestamp"        gencodec:"required"`
	Extra       []byte         `json:"extraData"        gencodec:"required"`
	MixDigest   common.Hash    `json:"mixHash"`
	Nonce       BlockNonce     `json:"nonce"`

	// BaseFee was added by EIP-1559 and is ignored in legacy headers.
	BaseFee *big.Int `json:"baseFeePerGas" rlp:"optional"`

	/*
		TODO (MariusVanDerWijden) Add this field once needed
		// Random was added during the merge and contains the BeaconState randomness
		Random common.Hash `json:"random" rlp:"optional"`
	*/
}
```

æœ€ç»ˆç”Ÿæˆçš„åŒºå—ç»“æ„ï¼Œæ ¸å¿ƒå­—æ®µå°±æ˜¯åŒºå—å¤´å’ŒåŒºå—ä½“ï¼ˆuncles + transactionsï¼‰

```go
// Block represents an entire block in the Ethereum blockchain.
type Block struct {
	header       *Header
	uncles       []*Header
	transactions Transactions

	// caches
	hash atomic.Value
	size atomic.Value

	// Td is used by package core to store the total difficulty
	// of the chain up to and including the block.
	td *big.Int

	// These fields are used by package eth to track
	// inter-peer block relay.
	ReceivedAt   time.Time
	ReceivedFrom interface{}
}
```



## åŒºå—ç”Ÿæˆæ­¥éª¤

æ ¹æ®ä¸Šé¢çš„åˆ†æï¼Œæˆ‘ä»¬è¦ç”ŸæˆåŒºå—ï¼Œè¦å¡«å……åŒºå—ä¸­åŒºå—ä½“çš„2ä¸ªå­—æ®µï¼ŒåŒºå—å¤´ä¸­çš„16ä¸ªå­—æ®µã€‚è¿™ä¸€éƒ¨åˆ†å°†å›é¡¾Gethä¸­Mineræ˜¯å¦‚ä½•ä¸€æ­¥æ­¥çš„ç”ŸæˆåŒºå—çš„ã€‚

### å·¥ä½œå‡†å¤‡

- é¦–å…ˆç”Ÿæˆæ‰“åŒ…ç”Ÿæˆæœ€åŸºæœ¬çš„åŒºå—å¤´ä¿¡æ¯ï¼šåŒºå—å¤´å®Œæˆåº¦ï¼ˆ5/16ï¼‰

  - ParentHash ä¸Šä¸€ä¸ªåŒºå—çš„BlockHash
  - Number åŒºå—é«˜åº¦
  - GasLimit å½“å‰åŒºå—ä¸­æ‰€åŒ…å«çš„äº¤æ˜“çš„Gasä¸Šé™
  - Time æ—¶é—´æˆ³
  - Coinbase æœ€åè·å¾—æŒ–çŸ¿æ”¶ç›Šçš„è´¦æˆ·

  ```go
  	//miner/worker.go/prepareWorkå‡½æ•°
  	header := &types.Header{
  		ParentHash: parent.Hash(),
  		Number:     num.Add(num, common.Big1),
  		GasLimit:   core.CalcGasLimit(parent.GasLimit(), w.config.GasCeil),
  		Time:       timestamp,
  		Coinbase:   genParams.coinbase,
  	}
  ```

- æ·»åŠ æ ¹æ®æå‰è®¾ç½®çš„å‚æ•°è®¾ç½®ExtraDataï¼ŒExtraDataå¹¶æ²¡æœ‰å•¥å®é™…çš„ç”¨é€”ï¼Œä¸è¿‡æ ¹æ®åœ¨etherscanä¸Šçš„è§‚å¯Ÿï¼ŒçŸ¿æ± æ€»ä¼šæ”¾ä¸€äº›å¥‡æ€ªå­—æ®µè¿›å»ï¼Œç„å­¦ç‚¹æ¥è¯´å¯èƒ½æ˜¯ç±»ä¼¼**å¹¸è¿æ•°å­—**çš„ä¸œè¥¿æ¥å¢åŠ è‡ªå·±çš„æŒ–çŸ¿æ¦‚ç‡ï¼ŸğŸ¤”ã€‚åŒºå—å¤´å®Œæˆåº¦ï¼ˆ6/16ï¼‰

  ```go
  	if !genParams.noExtra && len(w.extra) != 0 {
  		header.Extra = w.extra
  	}
  ```

- å¯¹äºä¿¡æ ‡é“¾ï¼Œå°†header.MixDigestè®¾ç½®ä¸ºgenParams.randomï¼Œåº”è¯¥æ˜¯éšæœºæ•°çš„beaconã€‚å¯¹äºä¼ ç»Ÿçš„PoW Consensusä¸ä¼šåœ¨è¿™é‡Œä¿®æ”¹MixDigestï¼Œè€Œæ˜¯åœ¨æŒ–çŸ¿çš„ç¯èŠ‚ä¿®æ”¹ï¼Œå› æ­¤è¯¥å­—æ®µæ­¤æ—¶è¿˜æ²¡ç¡®å®šä¸‹æ¥ã€‚

  ```go
  	// Set the randomness field from the beacon chain if it's available
  	if genParams.random != (common.Hash{}) {
  		header.MixDigest = genParams.random
  	}
  ```

- è®¾ç½®BaseFeeï¼šBaseFeeæ˜¯2021å¹´8æœˆLondonç¡¬åˆ†å‰å¼•å…¥åˆ°ç³»ç»Ÿçš„ç‰¹æ€§ã€‚è¯¥å­—æ®µå…·ä½“çš„ä½œç”¨åœ¨æ­¤ä¸åšä»‹ç»ï¼Œæ­¤å¤„åªæ˜¯è¯´æ˜è¯¥å­—æ®µå¯ä»¥é¢„å…ˆè¢«è®¡ç®—å¹¶è®¾ç½®ã€‚åŒºå—å¤´å®Œæˆåº¦ï¼ˆ7/16ï¼‰

  ```go
  	// Set baseFee and GasLimit if we are on an EIP-1559 chain
  	if w.chainConfig.IsLondon(header.Number) {
  		header.BaseFee = misc.CalcBaseFee(w.chainConfig, parent.Header())
      //å¦‚æœæœ¬åŒºå—åˆšå¥½æ˜¯ä¼¦æ•¦åˆ†å‰çš„ä¸€ä¸ªåŒºå—ï¼Œè®¾ç½®åŒºå—çš„GasLimit
  		if !w.chainConfig.IsLondon(parent.Number()) {
  			parentGasLimit := parent.GasLimit() * params.ElasticityMultiplier
  			header.GasLimit = core.CalcGasLimit(parentGasLimit, w.config.GasCeil)
  		}
  	}
  ```

- è®¾ç½®Difficultyï¼šæ ¹æ®ä¸Šä¸€ä¸ªåŒºå—çš„å‡ºå—æ—¶é—´å’Œæœ¬åŒºå—çš„timestampè¿›è¡Œè®¡ç®—ã€‚åŒºå—å¤´å®Œæˆåº¦ï¼ˆ8/16ï¼‰

  ```go
  	// Run the consensus preparation with the default or customized consensus engine.
  	if err := w.engine.Prepare(w.chain, header); err != nil {
  		log.Error("Failed to prepare header for sealing", "err", err)
  		return nil, err
  	}
  
  func (ethash *Ethash) Prepare(chain consensus.ChainHeaderReader, header *types.Header) error {
  	parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()-1)
  	if parent == nil {
  		return consensus.ErrUnknownAncestor
  	}
  	header.Difficulty = ethash.CalcDifficulty(chain, header.Time, parent)
  	return nil
  }
  ```

- æ‰“åŒ…å”å—ï¼šä¼˜å…ˆé€‰æ‹©æœ¬åœ°ç”Ÿæˆçš„å”å—è¿›è¡Œæ‰“åŒ…ï¼Œæ‰“åŒ…å”å—åè®¡ç®—uncleHashã€‚åŒºå—ä½“å®Œæˆåº¦ï¼ˆ1/2ï¼‰

  Tips: åœ¨å®é™…çš„ETHä¸­ï¼ŒHeaderä¸­çš„uncleHashæ˜¯åœ¨äº¤æ˜“æ‰§è¡Œå®Œæˆä¹‹åè®¡ç®—çš„ï¼Œäº‹å®ä¸Šè¿™ä¸ªç¡®å®å¯ä»¥æå‰ï¼Œä¸ºäº†è¯´æ˜çš„é€»è¾‘æ€§è¿™é‡Œå°†å…¶æå‰ã€‚åŒºå—å¤´å®Œæˆåº¦(9/16)

  ```go
  //miner/worker.go/func makeEnv	
  
  // when 08 is processed ancestors contain 07 (quick block)
  	for _, ancestor := range w.chain.GetBlocksFromHash(parent.Hash(), 7) {
  		for _, uncle := range ancestor.Uncles() {
  			env.family.Add(uncle.Hash())
  		}
  		env.family.Add(ancestor.Hash())
  		env.ancestors.Add(ancestor.Hash())
  	}
  	// Accumulate the uncles for the sealing work only if it's allowed.
  	if !genParams.noUncle {
  		commitUncles := func(blocks map[common.Hash]*types.Block) {
  			for hash, uncle := range blocks {
  				if len(env.uncles) == 2 {
  					break
  				}
  				if err := w.commitUncle(env, uncle.Header()); err != nil {
  					log.Trace("Possible uncle rejected", "hash", hash, "reason", err)
  				} else {
  					log.Debug("Committing new uncle to block", "hash", hash)
  				}
  			}
  		}
  		// Prefer to locally generated uncle
  		commitUncles(w.localUncles)
  		commitUncles(w.remoteUncles)
  	}
  ```

- æ‰“åŒ…äº¤æ˜“åˆ—è¡¨ï¼šä»äº¤æ˜“æ± ä¸­æ ¹æ®Priceå’ŒNonceæŒ‘é€‰å‡ºäº¤æ˜“æ‰“åŒ…è¿›å…¥åŒºå—ä¸­ã€‚åŒºå—ä½“è¿›åº¦ï¼ˆ2/2ï¼‰

  ```go
  func (w *worker) fillTransactions(interrupt *int32, env *environment) {
  	// Split the pending transactions into locals and remotes
  	// Fill the block with all available pending transactions.
  	pending := w.eth.TxPool().Pending(true)
  	localTxs, remoteTxs := make(map[common.Address]types.Transactions), pending
  	for _, account := range w.eth.TxPool().Locals() {
  		if txs := remoteTxs[account]; len(txs) > 0 {
  			delete(remoteTxs, account)
  			localTxs[account] = txs
  		}
  	}
  
  }
  ```



åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»åˆå§‹åŒ–äº†è¯¥åŒºå—å¤´çš„9ä¸ªå­—æ®µï¼Œå¹¶ä¸”å·²ç»å¡«å……å¥½äº†åŒºå—ä½“ï¼ŒåŒ…æ‹¬å”å—åˆ—è¡¨ä»¥åŠå¯èƒ½è¢«æ‰“åŒ…è¿›æœ¬åŒºå—çš„äº¤æ˜“å“ˆå¸Œã€‚è¿˜å‰©ä¸‹æœ€åçš„7ä¸ªåŒºå—å¤´å­—æ®µï¼Œå…¶ä¸­5ä¸ªå’Œäº¤æ˜“æ‰§è¡Œç›¸å…³ï¼Œ2ä¸ªå’ŒæŒ–çŸ¿ç›¸å…³ã€‚

---

### äº¤æ˜“æ‰§è¡Œ

å’Œäº¤æ˜“æ‰§è¡Œç›¸å…³çš„å‰©ä½™å­—æ®µæœ‰ï¼šTxHashï¼ŒRootï¼ŒReceiptHashï¼ŒBloomï¼ŒGasUsedã€‚ç®€å•ä»‹ç»ä¸€ä¸‹å„å­—æ®µçš„å«ä¹‰ï¼š

- TxHash: æäº¤äº†çš„æ‰€æœ‰äº¤æ˜“çš„ç»„æˆçš„MPTæ ‘çš„æ ¹Hashå€¼
- Rootï¼šæ‰§è¡Œäº¤æ˜“åï¼Œå¹¶è·å¾—å‡ºå—å¥–åŠ±åçš„ä¸–ç•ŒçŠ¶æ€
- ReceiptHashï¼šæ‰€æœ‰äº¤æ˜“æ‰§è¡Œå®Œç”Ÿæˆçš„å›æ‰§ç»„æˆçš„MPTæ ‘çš„æ ¹Hashå€¼
- Bloomï¼šæ‰€æœ‰äº¤æ˜“æ‰§è¡Œå®Œç”Ÿæˆçš„å›æ‰§æ„é€ çš„å¸ƒéš†è¿‡æ»¤å™¨
- GasUsedï¼šæ‰€æœ‰äº¤æ˜“æ‰§è¡Œåçš„èŠ±è´¹çš„Gasè´¹ç”¨

æ‰§è¡Œäº¤æ˜“è®¾è®¡åˆ°çš„å‡½æ•°ä»¥åŠç›¸å…³è¿‡ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
//miner/worker.go/fillTransactions

	if len(localTxs) > 0 {
		txs := types.NewTransactionsByPriceAndNonce(env.signer, localTxs, env.header.BaseFee)
		if w.commitTransactions(env, txs, interrupt) {
			return
		}
	}
	if len(remoteTxs) > 0 {
		txs := types.NewTransactionsByPriceAndNonce(env.signer, remoteTxs, env.header.BaseFee)
		if w.commitTransactions(env, txs, interrupt) {
			return
		}
	}

//miner/worker.go/commitTransactions
	gasLimit := env.header.GasLimit
	if env.gasPool == nil {
		env.gasPool = new(core.GasPool).AddGas(gasLimit)
	}
	var coalescedLogs []*types.Log

	//é’ˆå¯¹æ¯ä¸€ç¬”transaction
	env.state.Prepare(tx.Hash(), env.tcount)
	logs, err := w.commitTransaction(env, tx)


////miner/worker.go/commitTransaction
func (w *worker) commitTransaction(env *environment, tx *types.Transaction) ([]*types.Log, error) {
	snap := env.state.Snapshot()

	receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &env.coinbase, env.gasPool, env.state, env.header, tx, &env.header.GasUsed, *w.chain.GetVMConfig())
	if err != nil {
		env.state.RevertToSnapshot(snap)
		return nil, err
	}
	env.txs = append(env.txs, tx)
	env.receipts = append(env.receipts, receipt)

	return receipt.Logs, nil
}

//core/state_processor.go
func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, error) {
	msg, err := tx.AsMessage(types.MakeSigner(config, header.Number), header.BaseFee)
	if err != nil {
		return nil, err
	}
	// Create a new context to be used in the EVM environment
	blockContext := NewEVMBlockContext(header, bc, author)
	vmenv := vm.NewEVM(blockContext, vm.TxContext{}, statedb, config, cfg)
	return applyTransaction(msg, config, bc, author, gp, statedb, header.Number, header.Hash(), tx, usedGas, vmenv)
}


func applyTransaction(msg types.Message, config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, blockNumber *big.Int, blockHash common.Hash, tx *types.Transaction, usedGas *uint64, evm *vm.EVM) (*types.Receipt, error) {
	// Create a new context to be used in the EVM environment.
	txContext := NewEVMTxContext(msg)
	evm.Reset(txContext, statedb)

	// Apply the transaction to the current state (included in the env).
	result, err := ApplyMessage(evm, msg, gp)
	if err != nil {
		return nil, err
	}

	// Update the state with pending changes.
	var root []byte
	if config.IsByzantium(blockNumber) {
		statedb.Finalise(true)
	} else {
		root = statedb.IntermediateRoot(config.IsEIP158(blockNumber)).Bytes()
	}
	*usedGas += result.UsedGas

	// Create a new receipt for the transaction, storing the intermediate root and gas used
	// by the tx.
	receipt := &types.Receipt{Type: tx.Type(), PostState: root, CumulativeGasUsed: *usedGas}
	if result.Failed() {
		receipt.Status = types.ReceiptStatusFailed
	} else {
		receipt.Status = types.ReceiptStatusSuccessful
	}
	receipt.TxHash = tx.Hash()
	receipt.GasUsed = result.UsedGas

	// If the transaction created a contract, store the creation address in the receipt.
	if msg.To() == nil {
		receipt.ContractAddress = crypto.CreateAddress(evm.TxContext.Origin, tx.Nonce())
	}


	// Set the receipt logs and create the bloom filter.
	receipt.Logs = statedb.GetLogs(tx.Hash(), blockHash)
  
  //åœ¨æ‰§è¡Œäº¤æ˜“çš„æ—¶å€™ï¼Œè¿™éƒ¨åˆ†çš„ä»£ç æ˜¯å®Œå…¨æ²¡æœ‰çš„
	receipt.Bloom = types.CreateBloom(types.Receipts{receipt})
	receipt.BlockHash = blockHash
	receipt.BlockNumber = blockNumber
	receipt.TransactionIndex = uint(statedb.TxIndex())
	return receipt, err
}

```

ä¸€ä¸ªå¾ˆæœ‰è¶£çš„ä¸€ç‚¹æ˜¯ï¼Œåœ¨ä»¥å¤ªåŠçš„è®¾è®¡ä¸­receiptæ•°æ®ç»“æ„éœ€è¦å‚ä¸å…±è¯†çš„éƒ¨åˆ†ï¼ˆå³ç”¨æ¥è®¡ç®—receiptHashï¼‰åªæœ‰ä»¥ä¸‹è¿™5ä¸ªå­—æ®µï¼ŒåƒBlockHashè¿™ç§å­—æ®µåœ¨æ‰§è¡Œäº¤æ˜“çš„æ—¶å€™æ˜¯æœªå®Œå…¨ç¡®å®šä¸‹æ¥çš„ï¼Œç„¶è€Œåœ¨æ‰§è¡Œäº¤æ˜“çš„æ—¶å€™ä¹Ÿè¿˜æ˜¯è®¡ç®—äº†ã€‚æˆ‘ä¸ªäººç†è§£æ˜¯ä¸ºäº†ä»£ç å¤ç”¨ï¼Œè¯¥å‡½æ•°åŒæ ·ä¹Ÿä¼šè¢«ä½¿ç”¨åœ¨éªŒè¯æ›´è¿­çŠ¶æ€çš„æ—¶å€™ï¼Œå¯èƒ½åœ¨å†™ä»£ç çš„æ—¶å€™ä¸ºäº†æ–¹ä¾¿å°±ç›´æ¥ç”¨çš„è¯¥å‡½æ•°ï¼Œåæ­£ä¹Ÿä¸ä¼šå½±å“BlockHeaderä¸­Receiptçš„è®¡ç®—ç»“æœã€‚

```go
// Receipt represents the results of a transaction.
type Receipt struct {
	// Consensus fields: These fields are defined by the Yellow Paper
	Type              uint8  `json:"type,omitempty"`
	PostState         []byte `json:"root"`
	Status            uint64 `json:"status"`
	CumulativeGasUsed uint64 `json:"cumulativeGasUsed" gencodec:"required"`
	Bloom             Bloom  `json:"logsBloom"         gencodec:"required"`
	Logs              []*Log `json:"logs"              gencodec:"required"`
}
```
é€šè¿‡äº¤æ˜“çš„æ‰§è¡Œæˆ‘ä»¬å¾—åˆ°äº†å‡ ä¸ªé‡è¦çš„æ•°æ®

- transaction list æœ€ç»ˆè¢«æ‰“åŒ…åˆ°åŒºå—çš„äº¤æ˜“åˆ—è¡¨
- Receipt list æœ€ç»ˆè¢«æ‰“åŒ…åˆ°åŒºå—çš„å…¨éƒ¨äº¤æ˜“å¯¹åº”çš„å›æ‰§åˆ—è¡¨
- GasUsedï¼šæ¯æ‰§è¡Œä¸€ç¬”transactionï¼ŒèŠ±è´¹çš„Gaséƒ½ä¼šè®°å½•åœ¨header.GasUsedã€‚åŒºå—å¤´å®Œæˆåº¦ï¼ˆ12/16ï¼‰

æœ€åæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—å‡ºå‰©ä¸‹çš„å‡ ä¸ªå­—æ®µ

- Root: è®¡ç®—å‡ºå‡ºå—å¥–åŠ±ä¹‹åçŠ¶æ€æ ‘æ›´æ–°åˆ°æœ€æ–°ï¼Œå¾—åˆ°æœ€æ–°çŠ¶æ€ã€‚åŒºå—å¤´å®Œæˆåº¦ï¼ˆ11/16ï¼‰
- TxHashï¼šæ ¹æ®TransactionListï¼Œè°ƒç”¨Transactionå¯¹åº”çš„DeriveShaç®—å‡ºMPT Hash å®Œæˆåº¦ï¼ˆåŒºå—å¤´å®Œæˆåº¦13/16ï¼‰
- ReceiptHashï¼ŒBloomï¼šæ ¹æ®Receiptè®¡ç®—å›æ‰§çš„MPTHashå’ŒReceiptçš„Bloomè¿‡æ»¤å™¨ï¼ˆåŒºå—å¤´å®Œæˆåº¦14/16ï¼‰

```go
//miner/worker.go/commit function
		env := env.copy()
		block, err := w.engine.FinalizeAndAssemble(w.chain, env.header, env.state, env.txs, env.unclelist(), env.receipts)
		if err != nil {
			return err
		}

		// If we're post merge, just ignore
		if !w.isTTDReached(block.Header()) {
			select {
        //ä¼ è¾“ç»™taské€šé“è¯¥block
			case w.taskCh <- &task{receipts: env.receipts, state: env.state, block: block, createdAt: time.Now()}:
				w.unconfirmed.Shift(block.NumberU64() - 1)
				log.Info("Commit new sealing work", "number", block.Number(), "sealhash", w.engine.SealHash(block.Header()),
					"uncles", len(env.uncles), "txs", env.tcount,
					"gas", block.GasUsed(), "fees", totalFees(block, env.receipts),
					"elapsed", common.PrettyDuration(time.Since(start)))

			case <-w.exitCh:
				log.Info("Worker has exited")
			}
		}


//ethashç®—æ³•å¯¹åº”çš„FinalizeAndAssembleå‡½æ•°

// Finalize implements consensus.Engine, accumulating the block and uncle rewards,
// setting the final state on the header
func (ethash *Ethash) Finalize(chain consensus.ChainHeaderReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header) {
	// Accumulate any block and uncle rewards and commit the final state root
	accumulateRewards(chain.Config(), state, header, uncles)
	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))
}

// FinalizeAndAssemble implements consensus.Engine, accumulating the block and
// uncle rewards, setting the final state and assembling the block.
func (ethash *Ethash) FinalizeAndAssemble(chain consensus.ChainHeaderReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt) (*types.Block, error) {
	// Finalize block
	ethash.Finalize(chain, header, state, txs, uncles)

	// Header seems complete, assemble into a block and return
	return types.NewBlock(header, txs, uncles, receipts, trie.NewStackTrie(nil)), nil
}

//è®¡ç®—TxHashï¼ŒReceiptHashï¼ŒBloom
func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt, hasher TrieHasher) *Block {
	b := &Block{header: CopyHeader(header), td: new(big.Int)}

	// TODO: panic if len(txs) != len(receipts)
	if len(txs) == 0 {
		b.header.TxHash = EmptyRootHash
	} else {
		b.header.TxHash = DeriveSha(Transactions(txs), hasher)
		b.transactions = make(Transactions, len(txs))
		copy(b.transactions, txs)
	}

	if len(receipts) == 0 {
		b.header.ReceiptHash = EmptyRootHash
	} else {
		b.header.ReceiptHash = DeriveSha(Receipts(receipts), hasher)
		b.header.Bloom = CreateBloom(receipts) //æ ¹æ®æ‰€æœ‰çš„receiptsç”ŸæˆBloom
	}

	if len(uncles) == 0 {
		b.header.UncleHash = EmptyUncleHash
	} else {
		b.header.UncleHash = CalcUncleHash(uncles)
		b.uncles = make([]*Header, len(uncles))
		for i := range uncles {
			b.uncles[i] = CopyHeader(uncles[i])
		}
	}

	return b
}
```

æœ€åäº¤ä»˜ç»™ResultLoopè¿›è¡Œæ£€æŸ¥ï¼Œè®¡ç®—å¦‚ä»ŠåŒºå—çš„sealHashï¼Œå³ä½¿ç”¨é™¤äº†MixDigestå’ŒNonceå­—æ®µè®¡ç®—å‡ºçš„åŒºå—Hashå€¼ã€‚å¦‚æœé‡åˆ°ç›¸åŒçš„sealHashï¼Œè¯´æ˜è¯¥å—å·²ç»è¢«æäº¤è¿‡äº†ã€‚è‡³æ­¤ï¼ŒåŒºå—å·²ç»ç”Ÿæˆï¼Œå¯ä»¥äº¤ä»˜ç»™æŒ–çŸ¿è¿›ç¨‹è¿›è¡ŒæŒ–çŸ¿ã€‚

```go
			// Reject duplicate sealing work due to resubmitting.
			sealHash := w.engine.SealHash(task.block.Header())
			if sealHash == prev {
				continue
			}

// SealHash returns the hash of a block prior to it being sealed.
func (ethash *Ethash) SealHash(header *types.Header) (hash common.Hash) {
	hasher := sha3.NewLegacyKeccak256()

	enc := []interface{}{
		header.ParentHash,
		header.UncleHash,
		header.Coinbase,
		header.Root,
		header.TxHash,
		header.ReceiptHash,
		header.Bloom,
		header.Difficulty,
		header.Number,
		header.GasLimit,
		header.GasUsed,
		header.Time,
		header.Extra,
	}
	if header.BaseFee != nil {
		enc = append(enc, header.BaseFee)
	}
	rlp.Encode(hasher, enc)
	hasher.Sum(hash[:0])
	return hash
}
```

---

### æŒ–çŸ¿

å’ŒæŒ–çŸ¿ï¼ˆå…±è¯†ï¼‰ç›¸å…³çš„å­—æ®µæœ‰ï¼šNonce å’Œ MixDigestã€‚

- Nonceï¼šç”¨æ¥æŒ–çŸ¿æ—¶è°ƒæ•´çš„éšæœºæ•°ã€‚
- MixDigestï¼šæ˜¯ä»¥å¤ªåŠçš„PoWç®—æ³•Ethashè¿‡ç¨‹ä¸­ç”Ÿæˆçš„ç»“æœï¼ŒçŸ¿å·¥åœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­ä¼šå¾—åˆ°è¯¥å€¼å¹¶å°†å…¶å¡«å…¥åŒºå—å¤´ã€‚éªŒè¯è€…åœ¨éªŒè¯çš„æ—¶å€™ä¹Ÿä¼šéªŒè¯è®¡ç®—å¾—åˆ°çš„MixDigestæ˜¯å¦æ­£ç¡®ï¼Œè¯¥å€¼å¯ä»¥ä½œä¸ºçŸ¿å·¥åœ¨æ¶ˆè€—å†…å­˜è¿›è¡ŒæŒ–çŸ¿æ—¶çš„å·¥ä½œé‡è¯æ˜ã€‚

çŸ¿å·¥é€šè¿‡è°ƒæ•´Nonceå€¼ï¼Œé€šè¿‡sealHashï¼ˆå³å…¶ä»–14ä¸ªå­—æ®µç»„æˆçš„Hashå€¼ï¼‰ï¼Œnonceå’Œethashçš„datasetå¾—åˆ°ç¬¦åˆéš¾åº¦çš„ç»“æœï¼Œå¹¶ä¸”å›ç”ŸæˆMixDigestã€‚æœ€ç»ˆå°†MixDigestå’ŒNonceå¡«å…¥åŒºå—å¤´ç”ŸæˆåŒºå—ã€‚

```go
//miner/worker.go/taskLoop
//è¿™é‡Œè°ƒç”¨çš„w.engine.Sealå°±æ˜¯åœ¨è°ƒç”¨å…±è¯†ç®—æ³•ï¼ˆPOWï¼‰è¿›è¡ŒæŒ–çŸ¿
			if err := w.engine.Seal(w.chain, task.block, w.resultCh, stopCh); err != nil {
				log.Warn("Block sealing failed", "err", err)
				w.pendingMu.Lock()
				delete(w.pendingTasks, sealHash)
				w.pendingMu.Unlock()
			}

//ETHä½¿ç”¨çš„Ethash POWè¯æ˜å¦‚ä¸‹æ‰€ç¤º
// hashimoto aggregates data from the full dataset in order to produce our final
// value for a particular header hash and nonce.
func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) {
	// Calculate the number of theoretical rows (we use one buffer nonetheless)
	rows := uint32(size / mixBytes)

	// Combine header+nonce into a 64 byte seed
	seed := make([]byte, 40)
	copy(seed, hash)
	binary.LittleEndian.PutUint64(seed[32:], nonce)

	seed = crypto.Keccak512(seed)
	seedHead := binary.LittleEndian.Uint32(seed)

	// Start the mix with replicated seed
	mix := make([]uint32, mixBytes/4)
	for i := 0; i < len(mix); i++ {
		mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:])
	}
	// Mix in random dataset nodes
	temp := make([]uint32, len(mix))

	for i := 0; i < loopAccesses; i++ {
		parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows
		for j := uint32(0); j < mixBytes/hashBytes; j++ {
			copy(temp[j*hashWords:], lookup(2*parent+j))
		}
		fnvHash(mix, temp)
	}
	// Compress mix
	for i := 0; i < len(mix); i += 4 {
		mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3])
	}
	mix = mix[:len(mix)/4]

	digest := make([]byte, common.HashLength)
	for i, val := range mix {
		binary.LittleEndian.PutUint32(digest[i*4:], val)
	}
	return digest, crypto.Keccak256(append(seed, digest...))
}
```

---

### æœ€ç»ˆæäº¤

å¦‚æœmineræŒ–åˆ°äº†åŒºå—ï¼Œå°±ä¼šå°†è¯¥åŒºå—æäº¤ç»™resultLoopï¼ŒresultLoopä¼šå°†è¯¥Blockå­˜å…¥åˆ°æ•°æ®åº“ä¸­ï¼Œå†åœ¨ç½‘ç»œä¸­å¹¿æ’­åŒºå—ã€‚

```go
			// Commit block and state to database.
			_, err := w.chain.WriteBlockAndSetHead(block, receipts, logs, task.state, true)
			if err != nil {
				log.Error("Failed writing block to chain", "err", err)
				continue
			}
			log.Info("Successfully sealed new block", "number", block.Number(), "sealhash", sealhash, "hash", hash,
				"elapsed", common.PrettyDuration(time.Since(task.createdAt)))

			// Broadcast the block and announce chain insertion event
			w.mux.Post(core.NewMinedBlockEvent{Block: block})
```

## å‚è€ƒèµ„æ–™

- Geth Source Code
- [ä»¥å¤ªåŠæºç è§£è¯»ï¼ˆ16ï¼‰mineræ¨¡å—å’ŒWorkeræ¨¡å—æ¦‚è¿°](https://blog.csdn.net/lj900911/article/details/84853026)



